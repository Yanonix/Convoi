set CMN_gps "0 0"

# Attribution des adresses
set tmp [split $APG_ident ":"]
set CMN_adresse_vehicule [lindex $tmp 0]
set CMN_adresse_convoi [lindex $tmp 1]
unset tmp

set CMN_solitude true

# Sens de propagation
set CMN_mnemosens "s"
set CMN_amont -1
set CMN_aval 1

# Nombre de sauts
set CMN_mnemosauts "h"
set CMN_infini infinity

# TypeCom (unicast, ...)
set CMN_mnemotypecom "tC"
set CMN_mnemotypecom_unicast "uni"
set CMN_mnemotypecom_multicast "multi"
set CMN_mnemotypecom_beacon "beacon"
set CMN_mnemotypecom_convoi "con"

# TypeMsg
set CMN_mnemotypemsg "tM"

# Données
set CMN_mnemodonnees "d"

set CMN_mnemoadressevehiculedestinataire "aVD"
set CMN_mnemoadresseconvoidestinataire "aCD"
set CMN_mnemoadressevehiculeemetteur "aVE"
set CMN_mnemoadresseconvoiemetteur "aCE"
#################################################################

# DétectionConvoi
set CMN_mnemotypemsg_detection_convoi "DétectionConvoi"
set CMN_mnemoadressevehiculedetectee "aVN"
set CMN_mnemoadresseconvoidetectee "aCN"

# Solitude
set CMN_mnemotypemsg_solitude "Solitude"
set CMN_mnemosolitude "sol"

#################################################################


# Ecart
proc CMN_gps_ecart { gps1 gps2 } {
	# Ecart < 0 si gps1 derrière gps2
	# Ecart > 0 si gps1 devant gps2

	return [expr [lindex $gps1 0] - [lindex $gps2 0]]
}