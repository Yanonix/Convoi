namespace eval car {variable maxSteer 0.25 cars ""}
 set globalSpeed 0
 set voitureNumberOne "car1"
 #proc car::new {name c color {keys {<Left> <Right> <Up> <Down>}}} {
 proc car::new {name c color {keys {<Left> <Right> <Up> <Down>}}} {
    variable cars
    lappend cars $name
    interp alias {} $name {} car::dispatch $name
    namespace eval $name {
        variable angle 0 frontangle 0  speed 0 nbTours 0
    }
    namespace eval $name [list variable canvas $c]
    interp alias {} $name: {} namespace eval ::car::$name
    $c create line 44 55 66 55 -tag $name -width 2
    $c create line 44 80 66 80 -tag $name -width 3
    set tagpoly [append "poly" $name]
    $c create poly 51 45 48 87 62 87 59 45 -fill $color -tag $tagpoly
    wheel $name $c 44 55 left$name
    wheel $name $c 66 55 right$name
    wheel $name $c 44 80
    wheel $name $c 66 80
    set taghelmet [append "helmet" $name]
    $c create poly 52 67 52 73 58 73 58 67 -smooth 1 -fill white -tag  $taghelmet ;# driver's helmet
    foreach key $keys action {
      {deplacer -1} {deplacer +1} {changeLine 1} {changeLine -1}
    } {
        bind . $key [concat $name $action]
    }
 }
 proc car::dispatch {name cmd args} {eval ::car::$cmd $name $args}
 
 proc car::wheel {name c x y {tags ""}} {
    set dx 3; set dy 6
    set x0 [expr {$x - $dx}]
    set y0 [expr {$y - $dy}]
    set x1 [expr {$x + $dx}]
    set y1 [expr {$y + $dy}]
    $c create poly $x0 $y0 $x0 $y1 $x1 $y1 $x1 $y0 -fill black\
        -tag [lappend tags $name]
 }
 #
 # pour fixer une acceleration 
 # Be carrefour en negatif pour avancer sur la route
 #
 proc car::accelerate {names amount} {
    if {$names == "all"} {variable cars; set names $cars}
    foreach name $names {
        if $amount {
            if {[$name: set speed]>-1 || $amount > 0} {
                $name: incr speed $amount
            }
        } else {$name: set speed 0 ;# emergency stop}
    }
 }

#Fonction perso pour deplacement horizontal
# tres proche de accelerate mais pas limite avant/arriere
proc car::deplacer {names amount} {
    if {$names == "all"} {variable cars; set names $cars}
    foreach name $names {
        if {$name == "car1"} {
            set ::globalSpeed [expr $::globalSpeed + $amount]
            puts stdout $::globalSpeed
        }
        if $amount {
                $name: incr speed $amount
        } else {$name: set speed 0 ;# emergency stop}
    }
 }
 proc car::changeLine {names linechoice} {
    if {$names == "all"} {variable cars; set names $cars}
    foreach name $names {
        if {$linechoice > 0} {
                set c [$name: set canvas] ;# always the same, though...
                #set name [$c find withtag [append "poly" $name]]
                $c move $name 0 -35
            } else {
                set c [$name: set canvas] ;# always the same, though...
                $c move $name 0 35 
        }
}
}
 proc car::steer {name amount} {
    variable maxSteer
    set fa [$name: set frontangle]
    if {abs([$name: set angle] - ($fa  + $amount)) < $maxSteer} {
        $name: set frontangle [expr {$fa + $amount}]
 #       canvas'rotate [set ${name}::canvas] left$name $amount
 #       canvas'rotate [set ${name}::canvas] right$name $amount
    }
 }
 proc car::move {} {
    variable cars
    set title SR05
    foreach name $cars {
        set c [$name: set canvas] ;# always the same, though...
        set mean [expr {([$name: set angle]+[$name: set frontangle])/2.}]
        set speed [$name: set speed]
        set amount [expr {($mean - [$name: set angle])*$speed/5.}]
        canvas'rotate $c $name $amount
        $name: set angle [expr {[$name: set angle] + $amount}]
        $name: set frontangle [expr {[$name: set frontangle] + $amount}]
        set dx [expr {-$speed * sin([$name: set angle])}]
        set dy [expr {-$speed * cos([$name: set angle])}]
        # set dy 0
        #set dx 0
        #on dehabilite la voiture une a se mouvoir
        if {$name != "car1"} {
        $c move $name $dy $dx
        }
        foreach {x0 y0 x1 y1} [$c bbox $name] break
        #if {$x0<0 || $y0<0 || $x1>[$c cget -width] || $y1>[$c cget -height]} {
            # a modifier ici pour fct en boucle!!
         #   crash $name ;# went over canvas borders
        #}
       if { $x1>[$c cget -width] || $y1>[$c cget -height]} {
            # a modifier ici pour fct en boucle!!
            set dy 0
            set dx -600
            $c move $name $dx $dy ;# went over canvas borders
           # $name: set nbTours [expr {[$name : set nbTours] + 1}]
        }
        lappend title $name: [expr {$speed*10}] mph
    }
 }
  proc moveLabel {c name} {
    
# pour affecter les transformation au gros SR05
   namespace eval $name {
        variable angle 0 frontangle 0  speed -5 nbTours 0
    }
    namespace eval $name [list variable canvas $c]
    interp alias {} $name: {} namespace eval $name

    set title SR05
        set c [$name: set canvas] ;# always the same, though...
        set mean [expr {([$name: set angle]+[$name: set frontangle])/2.}]
        set speed [$name: set speed]
        set speed $::globalSpeed
       # puts stdout $speed
        #set speed [$name: set speed]
        set amount [expr {($mean - [$name: set angle])*$speed/5.}]
        canvas'rotate $c $name $amount
        $name: set angle [expr {[$name: set angle] + $amount}]
        $name: set frontangle [expr {[$name: set frontangle] + $amount}]
        set dx [expr {-$speed * sin([$name: set angle])}]
        set dy [expr {-$speed * cos([$name: set angle])}]
        set dx $dx
        set dy $dy
        # set dy 0
        #set dx 0
        $c move $name $dy $dx
        foreach {x0 y0 x1 y1} [$c bbox $name] break
        #if {$x0<0 || $y0<0 || $x1>[$c cget -width] || $y1>[$c cget -height]} {
            # a modifier ici pour fct en boucle!!
         #   crash $name ;# went over canvas borders
        #}
       if { $x0< -300 || $y0< -300 } {
            # a modifier ici pour fct en boucle!!
            set dy 0
            set dx 900
            $c move $name $dx $dy ;# went over canvas borders
           # $c find $name [expr nbTours + 1]
        }
        lappend title $name: [expr {$speed*10}] mph
 }
 #
 # Retourne la position de la voiture dand le canvas
 # PB: envoie plus de valeur que précue je ne les comprends pas 
 #
 proc car::getPos {c name} {
    set coordxy [$c coords $name]
    set coordxy [canvas'center $c $name]
    return coordxy
    #puts stdout $coordxy
    
}
#
 # Retourne la position relative de la voiturepar rapport a la voiture 1 dans le canvas
 # PB: envoie plus de valeur que précue je ne les comprends pas 
 #
 proc car::getRelativePos {c name} {
    #set coordxy [$c coords $name]
    set coordxy [canvas'center $c $name]
    set coordxyRel [canvas'center $c $::voitureNumberOne]
    set coordxyTmp [list [expr [lindex $coordxyRel 0] - [lindex $coordxy 0]] [expr [lindex $coordxyRel 1] - [lindex $coordxy 1]]]
    puts stdout $coordxyTmp
    return coordxyRel
    #puts stdout $coordxy
    
}
#
# permet de positionner une voiture a une position x y sur le canevas
#
proc car::setPos {c name x y} {
    #set coordxy [$c coords $name]
    $c move $name $x $y
    puts stdout ${x}${y}
    
}
#
# Permet de placer une voiture $name a la position posX et sur une voie de la route 
# line = 0 voie convoi
# line = 1 voie d'a coté?  
#
proc car::setPosInRoad {c name posX lineY} {
    set posY 0
    if { $lineY == 1} {
        # si on est dans l'autre voie que la voie convoi
        set posY -35
    }
    if { $lineY == -1} {
        # si on est dans l'autre voie que la voie convoi
        set posY 35
    }
    if { $posX > -35 && $posX < [$c cget -width]} {
        #car::setPos $c $name $posX $posY
        
    }
    #car::setPos $c $name $posX $posY 
}

 proc car::crash name {    
    if {[set ${name}::speed] > 3} {
        set c [set ${name}::canvas]
        $c create oval [$c bbox $name] -fill white -outline white\
            -stipple gray12 -tag cloud$name
        set center [canvas'center $c $name]
        foreach color {yellow orange red brown black} {
            after 250
            $c itemconfig cloud$name -fill $color -outline $color \
            -stipple gray12    ;# -stipple doesn't work on Win95
            eval $c scale cloud$name $center 1.4 1.4
            update idletasks
        }
        after 250
        $c delete cloud$name
    }
    set ${name}::speed 0 ;# in any case, stop that thing
 }
#-------- Generally useful routines:
 proc canvas'center {w tag} {
    foreach {x0 y0 x1 y1} [$w bbox $tag] break
    list [expr {($x0 + $x1) / 2.}] [expr {($y0 + $y1) / 2.}]
 }
 
 proc canvas'rotate {w tag angle} {
    foreach {xm ym} [canvas'center $w $tag] break
    foreach item [$w find withtag $tag] {
        set coords {}
        foreach {x y} [$w coords $item] {
            set rad [expr {hypot($x-$xm, $y-$ym)}]
            set th  [expr {atan2($y-$ym, $x-$xm)}]
            
            lappend coords [expr {$xm + $rad * cos($th - $angle)}]
            lappend coords [expr {$ym + $rad * sin($th - $angle)}]
        }
        #
        #On recupere les coordonée ici!
        #
        $w coords $item $coords 
    }
 }
 proc every {ms body} {eval $body; after $ms [info level 0]}
 

proc car::setColor {name c value} {
    set colorList [lappend color red blue black orange purple]
    set color [lindex $colorList $value]
    set tagpoly [append "poly" $name]
    $c itemconfigure $tagpoly -fill $color
    #set taghelmet [append "helmet" $name]
    #$c itemconfigure $taghelmet -fill white 
  
}


#-------------------- test and demo:
 pack [canvas .c -width 600 -height 400 -bg darkgreen]
 .c create text 300 300 -text SR05 \
    -font {Helvetica 64 {bold italic}} -fill green4 -tag "SR05Text"
# set track {45 45 300 45 560 45 560 360 45 360 45 45}
  set track {0 150 1000 150}
 .c create line $track -fill bisque -width 85 -smooth 1 -capstyle round ;# background
 .c create line $track -fill grey -width 75 -smooth 1 -capstyle round ;# race track
 #.c create line 300 5 300 80 -fill yellow ;# finish line
 .c create line $track -fill white -width 7 -smooth 1 -capstyle round ;# race track
 
 #Creation voiture 1
 car::new car1 .c red                  ;# default: cursor keys
  .c move  car1 350 100
 # 90 degrees rotation
  canvas'rotate .c car1 -1.570796326794 
 #Creation voiture 2
  car::new car2     .c blue   {d q z s}      ;# other keys for second car
  .c move  car2     -35 100
 
 # 90 degrees rotation
  canvas'rotate .c car2 -1.570796326794
  car::setColor car1 .c 0
 # .c label::move [.c find "SR05Text"]
 bind . <space> {car::deplacer all 1}




 every 50       {car::move}
 every 50       {moveLabel .c "SR05Text"}
 every 50       {car::getRelativePos .c car2}
 car::setPosInRoad .c car1 300 0


car::accelerate car2 -1
 #bind . <Up> {car::changeLine all 1}
 bind . <Escape> {exec wish $argv0 &; exit}
 bind . ? {console show}

